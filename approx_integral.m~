function area = approx_integral( f, a, b, rule, n )
%APPROX_INTEGRAL
%
%   area = approx_integral( f, a, b, rule, n )
%
%   Approximates the area under the curve defined by the function f 
%   over the interval [a,b].
%
%PARAMTERS:
%   f       The function to approximate the integral of. 
%   
%   a       The x-coordinate of the left boundry of the area.
%
%   b       The x-coordinate of the right boundry of the area.
%
%   rule    Determines the method to use in computing the approximation.
%           The choices are:
%               'trap'      for composite trapezoidal rule,
%               'simp'      for composite Simpson's 1/3 rule, 
%               'mid'       for composite midpoint rule. 
% 
%   n       The number of subintervals to use. Must be 1 or greater.
%
%RETURNS:
%   area    The approximate area under the curve for the interval [a,b].
%
%AUTHOR:    Kenneth Poppie
%DATE:      Dec. 4, 2016

% Make sure f is a function or a string.
if ~isa(f,'function_handle') && ~isa(f,'char')
    error('f must be a function handle or string to evalulate.');
end

% Check n
if n < 1
    error('Number of subinverals must be 1 or greater.');
end

% Approximate area.
area = 0;
if strcmpi(rule,'trap')
    
    % Composite trapezoidal rule %%%%%%%%%
    
    h = (b-a)/n;
    if isa(f,'function_handle')
        % Eval endpoints
        w_0 = f(a);
        w_n = f(b);

        % Eval midpoints
        w_mid = 0;
        for ii = 1:(n-1)
            w_mid = w_mid + 2*f(a+ii*h);
        end

    else % string
        % Eval endpoints
        x = a; w_0 = eval(f);
        x = b; w_n = eval(f);

        % Eval midpoints
        w_mid = 0;
        for ii = 1:(n-1)
            x = a+ii*h;
            w_mid = w_mid + 2*eval(f);
        end
    end

    % Compute area
    area = (h/2)*(w_0 + w_mid + w_n);

elseif strcmpi(rule,'simp')
    
    % Composite Simpson's 1/3 rule %%%%%%%%%%%
    
    h = (b-a)/n;
    if isa(f,'function_handle')
        % Eval endpoints
        w_0 = f(a);  w_n = f(b);

        % Eval midpoints
        w_mid = 0;
        for ii = 1:(n-1)
            x = a + ii*h;
            if mod(ii,2) == 1 % odd
                coef = 4;
            else
                coef = 2;
            end
            w_mid = w_mid + coef*f(x);
        end

    else % string
        % Eval endpoints
        x = a;
        w_0 = eval(f);
        x = b; 
        w_n = eval(f);

        % Eval midpoints
        w_mid = 0;
        for ii = 1:(n-1)
            if mod(ii,2) == 1 % odd
                coef = 4;
            else
                coef = 2;
            end
            x = a + ii*h;
            w_mid = w_mid + coef*eval(f);
        end
    end

    % Compute area
    area = (h/3)*(w_0 + w_mid + w_n);

elseif strcmpi(rule,'mid')
    
    % Composite midpoint rule %%%%%%%%%%%%%%
    
    h=(b-a)/(2*n);
    if isa(f,'function_handle')
        xp = a:h:b;
        x = xp(2:2:length(xp));
        w = 0;
        for ii = 1:length(x)
            w = w + f(x(ii));
        end
        area = 2*h*w;
    else 
        xp = a:h:b;
        x = xp(2:2:length(xp));
        area = 2*h*sum(eval(vectorize(f)));
    end
else
    error('Not a valid rule. Type ''help approx_integral'' %s', ...
        'to see rule choices.');
      
end % if

end % function

